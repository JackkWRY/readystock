-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Create Tables
create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  role text check (role in ('admin', 'staff')) default 'staff'
);

create table public.items (
  id bigint generated by default as identity primary key,
  name text not null,
  category text,
  quantity bigint default 0,
  min_quantity bigint default 0,
  is_deleted boolean default false,
  deleted_at timestamptz,
  created_at timestamptz default now()
);

create table public.transactions (
  id bigint generated by default as identity primary key,
  item_id bigint references public.items(id) on delete set null,
  action_type text check (action_type in ('CREATE', 'RECEIVE', 'WITHDRAW', 'UPDATE', 'DELETE')),
  amount bigint not null,
  note text,
  user_email text,
  created_at timestamptz default now()
);

-- 2. Enable RLS (Row Level Security)
alter table public.profiles enable row level security;
alter table public.items enable row level security;
alter table public.transactions enable row level security;

-- 3. Policies
-- Profiles: Admin sees all, User sees own
create policy "See own profile or Admin sees all" on public.profiles
  for select using (
    auth.uid() = id or 
    (auth.jwt() -> 'app_metadata' ->> 'role') = 'admin'
  );

create policy "Update own profile or Admin updates all" on public.profiles
  for update using (
    auth.uid() = id or 
    (auth.jwt() -> 'app_metadata' ->> 'role') = 'admin'
  );

-- Items: Authenticated read, Admin manage
create policy "Authenticated users can view items" on public.items
  for select using (auth.role() = 'authenticated');

create policy "Only Admin can manage items" on public.items
  for all using (
    (auth.jwt() -> 'app_metadata' ->> 'role') = 'admin'
  );

-- Transactions: Authenticated read/insert
create policy "Authenticated users can view transactions" on public.transactions
  for select using (auth.role() = 'authenticated');

create policy "Authenticated users can create transactions" on public.transactions
  for insert with check (auth.role() = 'authenticated');

-- 4. Triggers & Functions (Synced with Production DB & Localized to English)

-- A) Handle New User (Profile Creation)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'staff'); -- All new users default to staff role
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- B) Log Item Create/Update
create or replace function log_item_create_update()
returns trigger as $$
BEGIN
  -- Prevent redundant logging if the operation is handled by an RPC (e.g. receive/withdraw)
  -- The RPC will set 'app.skip_log' to true before updating items.
  IF current_setting('app.skip_log', true) = 'true' THEN
    RETURN NEW;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    INSERT INTO transactions (item_id, action_type, amount, note, user_email)
    VALUES (NEW.id, 'CREATE', NEW.quantity, 'Item created', COALESCE(auth.jwt() ->> 'email', 'system'));
  ELSIF (TG_OP = 'UPDATE') THEN
    -- Check for Soft Delete (is_deleted changed from false to true)
    IF (OLD.is_deleted = false AND NEW.is_deleted = true) THEN
       INSERT INTO transactions (item_id, action_type, amount, note, user_email)
       VALUES (NEW.id, 'DELETE', -OLD.quantity, 'Item deleted: ' || OLD.name, COALESCE(auth.jwt() ->> 'email', 'system'));
    
    -- Check for Quantity Change (only if not deleted)
    ELSIF (OLD.quantity <> NEW.quantity) THEN
      INSERT INTO transactions (item_id, action_type, amount, note, user_email)
      VALUES (NEW.id, 'UPDATE', NEW.quantity - OLD.quantity, 
              'System Update: Qty changed from ' || OLD.quantity || ' to ' || NEW.quantity, 
              COALESCE(auth.jwt() ->> 'email', 'system'));
    END IF;
  END IF;
  RETURN NEW;
END;
$$ language plpgsql security definer;

create trigger trg_log_item_create_update
  after insert or update on public.items
  for each row execute procedure log_item_create_update();




-- D) Role Sync (Profile -> Auth Metadata)
create or replace function public.sync_user_role()
returns trigger as $$
begin
  update auth.users
  set raw_app_meta_data = 
    coalesce(raw_app_meta_data, '{}'::jsonb) || 
    jsonb_build_object('role', new.role)
  where id = new.id;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_profile_role_change on public.profiles;
create trigger on_profile_role_change
  after insert or update of role on public.profiles
  for each row execute procedure public.sync_user_role();


-- 5. RPC Functions (Backend Logic)

-- Drop existing functions to avoid parameter name conflict errors
DROP FUNCTION IF EXISTS receive_item(bigint, bigint, text, text);
DROP FUNCTION IF EXISTS withdraw_item(bigint, bigint, text, text);

create or replace function receive_item(
  t_item_id bigint,
  t_amount bigint,
  t_note text,
  t_user_email text
)
returns void as $$
begin
  -- Set flag to skip trigger logging (prevent duplicate logs)
  perform set_config('app.skip_log', 'true', true);

  -- Update item quantity
  update public.items
  set quantity = quantity + t_amount
  where id = t_item_id;

  -- Log transaction (Specific Action)
  insert into public.transactions (item_id, action_type, amount, note, user_email)
  values (t_item_id, 'RECEIVE', t_amount, t_note, t_user_email);
end;
$$ language plpgsql;

create or replace function withdraw_item(
  t_item_id bigint,
  t_amount bigint,
  t_note text,
  t_user_email text
)
returns void as $$
begin
  -- Check stock availability
  if (select quantity from public.items where id = t_item_id) < t_amount then
    raise exception 'Insufficient stock quantity';
  end if;

  -- Set flag to skip trigger logging (prevent duplicate logs)
  perform set_config('app.skip_log', 'true', true);

  -- Update item quantity
  update public.items
  set quantity = quantity - t_amount
  where id = t_item_id;

  -- Log transaction (Specific Action)
  insert into public.transactions (item_id, action_type, amount, note, user_email)
  values (t_item_id, 'WITHDRAW', -t_amount, t_note, t_user_email);
end;
$$ language plpgsql;
